<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scan Student Answers</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 100%; /* Limits overall width on larger screens */
            margin: 0 auto; /* Centers the content */
            padding: 15px; /* Slightly reduced padding for mobile */
            box-sizing: border-box; /* Include padding in element's total width */
        }

        .student-info {
            margin-bottom: 20px;
            font-weight: bold;
            text-align: center; /* Center student info */
        }

        /* Styles for the camera activation button */
        .camera-activation {
            text-align: center;
            margin: 20px 0;
        }

        #activateCameraBtn {
            background: #007bff;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }

            #activateCameraBtn:hover {
                background: #0056b3;
            }

        /* Styles for the camera feed and container */
        .camera-container {
            position: relative;
            width: 100%; /* Takes full width of its parent */
            max-width: 97%; /* Limits max width on larger screens */
            margin: 0 auto;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            display: flex; /* Use flexbox for centering content */
            flex-direction: column; /* Stack content vertically */
            align-items: center; /* Center horizontally */
            justify-content: center; /* Center vertically */
            min-height: 500px; /* Ensure visibility even without stream, adjust as needed */
            /* REMOVED: aspect-ratio: 4/3; */
        }

        #cameraFeed {
            width: 100%;
            height: 100%; /* Take full height of container */
            display: block;
            background-color: #000;
            /* CHANGED: from 'contain' to 'cover' */
            object-fit: cover; /* Ensures video fills the container without distortion */
        }

        .camera-placeholder {
            color: #fff;
            font-size: 1.1em;
            text-align: center;
            padding: 20px;
        }

        /* Take photo button - simplified white circle */
        #takePhotoBtn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            background: white;
            border: 4px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            z-index: 10;
        }

            #takePhotoBtn:hover {
                transform: translateX(-50%) scale(1.1);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            }

            #takePhotoBtn:active {
                transform: translateX(-50%) scale(0.95);
            }

            #takePhotoBtn:disabled {
                background: #ccc;
                border-color: #ccc;
                cursor: not-allowed;
                opacity: 0.6;
            }

                #takePhotoBtn:disabled:hover {
                    transform: translateX(-50%) scale(1);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                }

        /* Flash effect for photo capture */
        .camera-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
        }

            .camera-flash.active {
                animation: flashEffect 0.3s ease-out;
            }

        @keyframes flashEffect {
            0% {
                opacity: 0;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        .upload-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 20px; /* Slightly adjusted padding */
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            width: 100%; /* Make buttons full width */
            box-sizing: border-box; /* Include padding in width */
        }

            .upload-btn:hover {
                background: #0056b3;
            }

            .upload-btn:disabled {
                background: #6c757d;
                cursor: not-allowed;
            }

        /* Main upload button at the bottom */
        #uploadBtn {
            margin-top: 20px;
            margin-bottom: 10px;
            width: 100%; /* Ensure it's full width */
            max-width: 400px; /* Limit max width on larger screens */
            display: block; /* Ensure it takes full width */
            margin-left: auto; /* Center it */
            margin-right: auto; /* Center it */
        }

        .preview-container {
            display: grid;
            /* On mobile, show 2 columns, scaling down to 1 if necessary */
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .preview-item {
            position: relative;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f9f9f9;
        }

            .preview-item img {
                width: 100%;
                height: 100px; /* Fixed height for consistency */
                object-fit: cover; /* Cover the area, cropping if necessary */
            }

        .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 0, 0, 0.8); /* Slightly transparent red */
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px; /* Slightly larger for easier tapping */
            height: 28px;
            cursor: pointer;
            font-size: 16px; /* Larger font for 'x' */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-size: 0.95em;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hidden {
            display: none;
        }

        /* Media query for larger screens */
        @media (min-width: 600px) {
            .preview-container {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* More columns on wider screens */
            }

            .preview-item img {
                height: 120px; /* Slightly taller previews on larger screens */
            }

            #uploadBtn {
                max-width: 300px; /* Slightly smaller max-width for main button on larger screens */
            }
        }
    </style>
</head>
<body>

    <div id="studentInfo" class="student-info">Loading...</div>

    <div id="cameraActivation" class="camera-activation">
        <button id="activateCameraBtn" class="upload-btn">
            Activate Camera
        </button>
    </div>

    <div id="cameraContainer" class="camera-container hidden">
        <video id="cameraFeed" autoplay playsinline class="hidden"></video>
        <div id="cameraPlaceholder" class="camera-placeholder">
            Attempting to start camera...
        </div>
        <canvas id="cameraCanvas" class="hidden"></canvas> <!-- Hidden canvas for capturing frames -->
        <button id="takePhotoBtn" disabled></button>
        <div class="camera-flash" id="cameraFlash"></div>
    </div>

    <button id="uploadBtn" class="upload-btn" disabled>
        Upload All New Images
    </button>

    <div id="noImagesMessage" class="status-info">
        No images uploaded yet. Use the camera to capture the student's answer sheets.
    </div>

    <div id="imagePreviews" class="preview-container"></div>

    <script>
        // Configuration
        const SUPABASE_URL = 'https://uagiatfoiwusxafxskvp.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVhZ2lhdGZvaXd1c3hhZnhza3ZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyODc0NjYsImV4cCI6MjA2NDg2MzQ2Nn0.b0wIEHgENkhzkp3qHAotqbLTq7BwsqgM7b0ksAl3h1U';
        const STORAGE_BUCKET = 'exam-visuals';

        // Initialize Supabase client
        const { createClient } = supabase;
        const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Global variables
        let scanSessionId = null;
        let sessionToken = null;
        // Stores objects like { id: uuid, type: 'new'|'uploaded', data: File|string }
        let allImagesForSession = [];
        let cameraStream = null;
        let bestRearCamera = null;

        // DOM elements
        const studentInfo = document.getElementById('studentInfo');
        const imagePreviews = document.getElementById('imagePreviews');
        const uploadBtn = document.getElementById('uploadBtn');
        const noImagesMessage = document.getElementById('noImagesMessage');

        const cameraActivation = document.getElementById('cameraActivation');
        const activateCameraBtn = document.getElementById('activateCameraBtn');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraFeed = document.getElementById('cameraFeed');
        const cameraCanvas = document.getElementById('cameraCanvas');
        const cameraPlaceholder = document.getElementById('cameraPlaceholder');
        const takePhotoBtn = document.getElementById('takePhotoBtn');
        const cameraFlash = document.getElementById('cameraFlash');

        // Utility to generate a unique ID for local image management
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Show status messages (removed - keeping function for compatibility)
        function showStatus(message, type) {
            // Status messages removed per user request
        }

        async function findBestRearCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                const rearCameras = [];

                for (const device of videoDevices) {
                    try {
                        // Test each camera to get its capabilities
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { deviceId: device.deviceId }
                        });

                        const track = stream.getVideoTracks()[0];
                        const capabilities = track.getCapabilities();
                        const settings = track.getSettings();

                        // Stop the test stream immediately
                        stream.getTracks().forEach(track => track.stop());

                        // Check if this is a rear camera
                        const label = device.label || '';
                        const isRearCamera = label.toLowerCase().includes('back') ||
                            label.toLowerCase().includes('rear') ||
                            label.toLowerCase().includes('environment') ||
                            settings.facingMode === 'environment';

                        if (isRearCamera) {
                            const maxResolution = capabilities.width && capabilities.height ?
                                capabilities.width.max * capabilities.height.max : 0;

                            rearCameras.push({
                                deviceId: device.deviceId,
                                label: label,
                                maxResolution: maxResolution,
                                capabilities: capabilities,
                                settings: settings
                            });
                        }
                    } catch (error) {
                        console.warn(`Could not test camera ${device.deviceId}:`, error);
                    }
                }

                if (rearCameras.length === 0) {
                    console.log('No rear cameras found, will use default');
                    return null;
                }

                // Sort by resolution (highest first) and pick the best one
                rearCameras.sort((a, b) => b.maxResolution - a.maxResolution);
                bestRearCamera = rearCameras[0];

                console.log('Selected rear camera:', bestRearCamera.label, 'Resolution:', bestRearCamera.maxResolution);
                return bestRearCamera;

            } catch (error) {
                console.error('Error finding rear camera:', error);
                return null;
            }
        }

        /**
         * Get optimal camera constraints for document scanning
         */
        function getOptimalConstraints(cameraInfo) {
            let constraints;

            if (cameraInfo) {
                // Use specific camera with high quality settings
                constraints = {
                    deviceId: cameraInfo.deviceId,
                    width: { ideal: 1920, min: 1280 },
                    height: { ideal: 1080, min: 720 },
                    focusMode: 'continuous',
                    exposureMode: 'continuous',
                    whiteBalanceMode: 'continuous'
                };

                // Add advanced constraints if supported
                if (cameraInfo.capabilities) {
                    const caps = cameraInfo.capabilities;

                    // Set focus distance for document scanning (typically 20-50cm)
                    if (caps.focusDistance) {
                        constraints.focusDistance = { ideal: 0.3 }; // 30cm
                    }

                    // Use highest available resolution
                    if (caps.width && caps.height) {
                        constraints.width = {
                            ideal: Math.min(caps.width.max, 1920),
                            min: Math.min(caps.width.min || 640, 1280)
                        };
                        constraints.height = {
                            ideal: Math.min(caps.height.max, 1080),
                            min: Math.min(caps.height.min || 480, 720)
                        };
                    }

                    // Set frame rate for stability
                    if (caps.frameRate) {
                        constraints.frameRate = { ideal: 30, max: 30 };
                    }
                }
            } else {
                // Fallback to environment camera
                constraints = {
                    facingMode: 'environment',
                    width: { ideal: 1920, min: 1280 },
                    height: { ideal: 1080, min: 720 },
                    focusMode: 'continuous',
                    exposureMode: 'continuous',
                    whiteBalanceMode: 'continuous'
                };
            }

            return constraints;
        }

        // Initialize page on load
        document.addEventListener('DOMContentLoaded', async () => {
            const urlParams = new URLSearchParams(window.location.search);
            sessionToken = urlParams.get('token');

            if (!sessionToken) {
                studentInfo.textContent = 'Error: No session token provided.';
                return;
            }

            try {
                // Fetch scan session details using the Edge Function
                const response = await fetch(`${SUPABASE_URL}/functions/v1/get-scan-session?token=${sessionToken}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to load session');
                }

                const session = await response.json();

                scanSessionId = session.id;

                // Populate allImagesForSession with existing uploaded images from the session
                if (session.uploaded_image_paths && session.uploaded_image_paths.length > 0) {
                    allImagesForSession = session.uploaded_image_paths.map(url => ({
                        id: generateUUID(), // Assign a new ID for local management
                        type: 'uploaded',
                        data: url
                    }));
                }

                studentInfo.textContent = `Student: ${session.student_name || session.student_number || 'Unknown'}`;
                renderPreviews(); // Display existing images
                updateNoImagesMessage(); // Update message based on images
                updateUploadButton(); // Update upload button state

            } catch (error) {
                console.error('Initialization error:', error);
                studentInfo.textContent = `Error: ${error.message}`;
            }
        });

        // Event listeners
        activateCameraBtn.addEventListener('click', activateCamera);
        takePhotoBtn.addEventListener('click', takePhoto);
        uploadBtn.addEventListener('click', uploadImages);

        /**
         * Activates the camera and shows the camera view
         */
        async function activateCamera() {
            cameraActivation.classList.add('hidden');
            cameraContainer.classList.remove('hidden');

            // Find the best rear camera first
            await findBestRearCamera();
            await startCamera();
        }

        /**
         * Starts the camera stream with optimal settings for document scanning
         */
        async function startCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }

            cameraPlaceholder.textContent = 'Starting camera...';
            cameraFeed.classList.add('hidden');
            cameraPlaceholder.classList.remove('hidden');

            try {
                const constraints = getOptimalConstraints(bestRearCamera);

                console.log('Starting camera with constraints:', constraints);

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: constraints
                });

                cameraStream = stream;
                cameraFeed.srcObject = stream;

                // Wait for video to load and get actual settings
                cameraFeed.onloadedmetadata = () => {
                    // --- START: NEW LOGIC TO SET CONTAINER ASPECT RATIO ---
                    const videoWidth = cameraFeed.videoWidth;
                    const videoHeight = cameraFeed.videoHeight;

                    // Calculate the true aspect ratio of the video stream
                    const aspectRatio = videoWidth / videoHeight;

                    // Set the container's aspect ratio to match the video's
                    cameraContainer.style.aspectRatio = aspectRatio;
                    // --- END: NEW LOGIC ---

                    const track = stream.getVideoTracks()[0];
                    const settings = track.getSettings();
                    console.log('Camera settings:', settings);
                    console.log('Video dimensions:', videoWidth, 'x', videoHeight);
                    console.log('Applied aspect ratio to container:', aspectRatio);

                    cameraFeed.classList.remove('hidden');
                    cameraPlaceholder.classList.add('hidden');
                    takePhotoBtn.disabled = false;
                };

            } catch (error) {
                console.error('Error accessing camera:', error);
                cameraFeed.classList.add('hidden');
                cameraPlaceholder.classList.remove('hidden');
                cameraPlaceholder.textContent = `Camera access failed: ${error.message}`;
                takePhotoBtn.disabled = true;

                // Try basic fallback
                try {
                    const fallbackStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });

                    cameraStream = fallbackStream;
                    cameraFeed.srcObject = fallbackStream;
                    cameraFeed.classList.remove('hidden');
                    cameraPlaceholder.classList.add('hidden');
                    takePhotoBtn.disabled = false;

                } catch (fallbackError) {
                    console.error('Fallback camera failed:', fallbackError);
                }
            }
        }

        /**
         * Stops the camera stream and releases resources.
         */
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
                cameraFeed.srcObject = null;
                cameraFeed.classList.add('hidden');
                cameraPlaceholder.classList.remove('hidden');
                cameraPlaceholder.textContent = 'Camera is off.';
                takePhotoBtn.disabled = true;
            }
        }

        /**
         * Captures a high-quality photo from the current camera feed.
         */
        function takePhoto() {
            if (!cameraStream) {
                return;
            }

            // Trigger flash effect
            cameraFlash.classList.add('active');
            setTimeout(() => {
                cameraFlash.classList.remove('active');
            }, 300);

            const context = cameraCanvas.getContext('2d');

            // Use the actual video dimensions for maximum quality
            const videoWidth = cameraFeed.videoWidth;
            const videoHeight = cameraFeed.videoHeight;

            // Set canvas to match video resolution exactly
            cameraCanvas.width = videoWidth;
            cameraCanvas.height = videoHeight;

            // Draw the current video frame onto the canvas at full resolution
            context.drawImage(cameraFeed, 0, 0, videoWidth, videoHeight);

            // Convert canvas content to a high-quality Blob
            cameraCanvas.toBlob((blob) => {
                if (blob) {
                    const file = new File([blob], `scan_${Date.now()}.jpg`, { type: 'image/jpeg' });
                    const newImage = {
                        id: generateUUID(),
                        type: 'new',
                        data: file
                    };
                    allImagesForSession.push(newImage);
                    renderPreviews();
                }
            }, 'image/jpeg', 0.95); // High quality JPEG (95%)
        }

        // Stop camera when navigating away from the page
        window.addEventListener('beforeunload', stopCamera);
        window.addEventListener('pagehide', stopCamera);

        /**
         * Renders all images (newly captured and already uploaded) in the preview section.
         */
        function renderPreviews() {
            imagePreviews.innerHTML = ''; // Clear existing previews

            updateNoImagesMessage(); // Update the "No images" message visibility
            updateUploadButton(); // Update the upload button's disabled state

            if (allImagesForSession.length === 0) {
                return; // No images to render
            }

            allImagesForSession.forEach(item => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';

                const img = document.createElement('img');
                // For new images, create an object URL; for uploaded, use the direct URL
                img.src = item.type === 'new' ? URL.createObjectURL(item.data) : item.data;
                img.alt = 'Preview';

                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = 'Ã—';
                removeBtn.onclick = () => removeImage(item.id); // Pass the unique ID for removal

                previewItem.appendChild(img);
                previewItem.appendChild(removeBtn);

                imagePreviews.appendChild(previewItem);

                // Revoke object URL for 'new' images after they are loaded to free memory
                if (item.type === 'new') {
                    img.onload = () => URL.revokeObjectURL(img.src);
                }
            });
        }

        /**
         * Updates the state of the main "Upload All New Images" button.
         */
        function updateUploadButton() {
            const hasNewImages = allImagesForSession.some(item => item.type === 'new');
            uploadBtn.disabled = !hasNewImages;
        }

        /**
         * Toggles the visibility of the "No images uploaded yet" message.
         */
        function updateNoImagesMessage() {
            const hasImages = allImagesForSession.length > 0;
            noImagesMessage.classList.toggle('hidden', hasImages);
        }

        /**
         * Uploads all newly captured images to Supabase Storage and updates the session record.
         */
        async function uploadImages() {
            const newFilesToUpload = allImagesForSession.filter(item => item.type === 'new');

            if (newFilesToUpload.length === 0) {
                return;
            }

            uploadBtn.disabled = true;
            const originalText = uploadBtn.textContent;
            uploadBtn.textContent = 'Uploading...';

            try {
                const uploadedUrls = [];
                for (const item of newFilesToUpload) {
                    const file = item.data;
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${Date.now()}_${Math.random().toString(36).substring(7)}.${fileExt}`;
                    const filePath = `temp_scans/${sessionToken}/${fileName}`;

                    // Upload file to Supabase Storage
                    const { error: uploadError } = await sb.storage
                        .from(STORAGE_BUCKET)
                        .upload(filePath, file);

                    if (uploadError) throw uploadError;

                    // Get public URL of the uploaded file
                    const { data: urlData } = sb.storage
                        .from(STORAGE_BUCKET)
                        .getPublicUrl(filePath);

                    uploadedUrls.push(urlData.publicUrl);

                    // Update the item's type and data in our local array
                    item.type = 'uploaded';
                    item.data = urlData.publicUrl;
                }

                // Fetch current uploaded_image_paths from DB to merge with new ones
                const { data: currentSessionData, error: fetchError } = await sb
                    .from('scan_sessions')
                    .select('uploaded_image_paths')
                    .eq('id', scanSessionId)
                    .single();

                if (fetchError) throw fetchError;

                const existingPaths = currentSessionData.uploaded_image_paths || [];
                const updatedPaths = [...existingPaths, ...uploadedUrls];

                // Update the scan_sessions table with the merged list of image paths
                // Update the scan_sessions table with the merged list of image paths AND set status to ready for processing
                const { error: updateError } = await sb
                    .from('scan_sessions')
                    .update({
                        uploaded_image_paths: updatedPaths,
                        status: 'uploaded'  // NEW: Signal that images are ready for processing
                    })
                    .eq('id', scanSessionId);

                if (updateError) throw updateError;

                renderPreviews(); // Re-render to reflect 'uploaded' status for all images
                updateUploadButton(); // Update button state (should be disabled if no new images)

                // Change button text to show success
                uploadBtn.textContent = 'Images Uploaded Successfully!';
                setTimeout(() => {
                    uploadBtn.textContent = originalText;
                }, 3000);

            } catch (error) {
                console.error('Upload error:', error);
                uploadBtn.textContent = originalText;
            } finally {
                uploadBtn.disabled = false; // Re-enable button in case of failure
            }
        }

        /**
         * Removes an image from the local list and, if uploaded, from Supabase Storage and DB.
         * @param {string} idToRemove - The unique ID of the image to remove.
         */
        async function removeImage(idToRemove) {
            const indexToRemove = allImagesForSession.findIndex(item => item.id === idToRemove);
            if (indexToRemove === -1) return; // Image not found

            const itemToRemove = allImagesForSession[indexToRemove];

            if (itemToRemove.type === 'uploaded') {
                // If it's an already uploaded image, delete from Supabase Storage and DB
                const urlToRemove = itemToRemove.data;
                // Extract filename from the URL to construct the storage path
                const filename = urlToRemove.split('/').pop();
                const filePath = `temp_scans/${sessionToken}/${filename}`;

                try {
                    // Delete from Supabase Storage
                    const { error: deleteError } = await sb.storage.from(STORAGE_BUCKET).remove([filePath]);
                    if (deleteError) throw deleteError;

                    // Fetch current paths from DB to ensure we're updating the latest version
                    const { data: currentSessionData, error: fetchError } = await sb
                        .from('scan_sessions')
                        .select('uploaded_image_paths')
                        .eq('id', scanSessionId)
                        .single();

                    if (fetchError) throw fetchError;

                    const existingPaths = currentSessionData.uploaded_image_paths || [];
                    // Filter out the URL of the image being removed
                    const updatedPaths = existingPaths.filter(path => path !== urlToRemove);

                    // Update the scan_sessions table with the new list of paths
                    const { error: updateError } = await sb
                        .from('scan_sessions')
                        .update({ uploaded_image_paths: updatedPaths })
                        .eq('id', scanSessionId);

                    if (updateError) throw updateError;

                } catch (error) {
                    console.error('Remove image error:', error);
                    return; // Stop if deletion failed
                }
            }

            // Remove from local array and re-render the previews
            allImagesForSession.splice(indexToRemove, 1);
            renderPreviews();
        }
    </script>
</body>
</html>
